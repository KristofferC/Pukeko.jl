# This file is a part of Mimir.jl.

__precompile__(false)
module Pukeko

export @test, @test_throws, @parametric

if VERSION <= v"0.7"
    const Nothing = Void
end

"""
    TEST_PREFIX

Functions with this string at the the start of their name will be treated as
self-contained sets of tests.
"""
const TEST_PREFIX = "test_"

"""
    TestException

The `Exception`` thrown when a Mimir test fails. Used by `run_tests` to
distinguish between test errors and unexpected errors.
"""
struct TestException <: Exception
    message::String
end
Base.show(io::IO, ex::TestException) = print(io, ex.message)

"""
    test_true(value)

Throws iff `value` is not `true`. Calls to this are generated by `@test`.
"""
function test_true(value)

    if value != true
        throw(TestException("Expression did not evaluate to `true`: " *
                            string(value)))
    end
    return nothing
end

"""
    test_equal(value_left, value_right)

Test that `value_left` is equal to `value_right`. Calls to this are
generated by `@test` for the case of `@test expr_left == expr_right`.
"""
function test_equal(value_left, value_right)
    if value_left != value_right
        throw(TestException("Expression did not evaluate to `true`: " *
                            string(value_left) * " != " *
                            string(value_right)))
    end
    return nothing
end

"""
    @test expression

Test that `expression` is `true`.
"""
macro test(expression)
    # If `expression` is of form `expr_left == expr_right` -> `test_equal`.
    # Otherwise, use `test_true`.
    if (expression.head == :call && expression.args[1] == :(==) &&
        length(expression.args) == 3)
        return quote
            lhs = $(esc(expression.args[2]))
            rhs = $(esc(expression.args[3]))
            test_equal(lhs, rhs)
        end
    end
    return quote
        test_true($(esc(expression)))
    end
end

"""
    @test_throws exception_type expression

Test that `expression` throws an exception of type `exception_type`.
"""
macro test_throws(exception_type, expression)
    return quote
        exception_thrown = true
        try
            $(esc(expression))
            global exception_thrown = false
        catch exception
            expected_type = $(esc(exception_type))
            if exception isa expected_type
                # Test passes
            else
                throw(TestException("Expression threw exception of " *
                                    "type $(typeof(exception)), but " *
                                    "expected $(expected_type)"))
            end
        end
        if !exception_thrown
            throw(TestException("Expression did not throw an exception, " *
                                "expected $(expected_type) exception"))
        end
    end
end

@static if VERSION >= v"0.7"
    compat_name(mod) = names(mod, all=true)
    import Printf: @sprintf
else
    compat_name(mod) = names(mod, true)
end

"""
    run_tests(module_to_test; fail_fast=false)

Runs all the sets of tests in module `module_to_test`. Test sets are defined
as functions with names that begin with `TEST_PREFIX`. A summary is printed
after all test sets have been run and if there were any failures an
exception is thrown.

Configuration options:

  * If `fail_fast==false` (default), if any one test function fails, the
    others will still run. If `true`, testing will stop on the first
    failure. The commandline argument `--PUKEKO_FAIL_FAST` will override
    `fail_fast` to `true` for all `run_tests` calls.
  * If `timing==true` (default is `false`), print elapsed time and memory
    allocation statistics for every test function. The commandline
    argument `--PUKEKO_TIMING` will override `timing` to `true` for all
    `run_tests` calls.
  * If `match_name!=nothing` (default is `nothing`), only run tests that
    contain `match_name` in their names. The commandline argument
    `--PUKEKO_MATH=str` will override `match_name` to `str` for all
    `run_tests` calls.
"""
function run_tests(folder::AbstractString, fail_fast::Bool=false, timing::Bool=false,
                   match_name::Union{AbstractString, Nothing}=nothing)
    # Parse commandline arguments.
    for arg in ARGS
        if arg == "--PUKEKO_FAIL_FAST"
            fail_fast = true
        elseif arg == "--PUKEKO_TIMING"
            timing = true
        elseif startswith(arg, "--PUKEKO_MATCH")
            match_name = split(arg, "=")[2]
        end
    end

    # Collect files
    files = String[]
    for f in readdir(folder)
        @show f
        if isfile(joinpath(folder, f)) && startswith(f, "test_")
            push!(files, joinpath(folder, f))
        end
    end
    @show files
    
    # IMPORTANT! Each file is included before the tests are run!!!

    test_modules = Module[]

    for f in files
        m = Module(Symbol(f))
        push!(test_modules, m)
        println("Including... $f in $m")
        Base.include(m, f)
        run_tests_module(m)
    end
end

function run_tests_module(mod::Module)
    # Keep track of failures to summarize at end.
    test_functions = 0
    for sym in names(mod; all=true)
        # If not a function, skip to next
        if !(getfield(mod, sym) isa Function)
             continue
        end
        # If not a test function, skip to next function.
        if !startswith(string(sym), TEST_PREFIX)
            continue
        end

        @show sym
    end
end

"""
    parametric(module_to_test, func, iterable)

Create a version of `func` that is prefixed with `TEST_PREFIX` in
`module_to_test` for each value in `iterable`. If a value in `iterable` is
a tuple, it is splatted into the function arguments.
"""
function parametric(module_to_test, func, iterable)
    for (index, value) in enumerate(iterable)
        func_name = Symbol(string(TEST_PREFIX, func, index))
        if value isa Tuple
            @eval module_to_test $func_name() = $func($(value)...)
        else
            @eval module_to_test $func_name() = $func($(value))
        end
    end
end

"""
    @parametric func iterable

Create a version of `func` that is prefixed with `TEST_PREFIX` in the module
that this macro is called for each value in `iterable`. If a value in
`iterable` is a tuple, it is splatted into the function arguments.
"""
macro parametric(func, iterable)
    @static if VERSION >= v"0.7"
        module_ = __module__
    else
        module_ = current_module()
    end
    return quote
        parametric($(module_), $(esc(func)), $(esc(iterable)))
    end
end

end
